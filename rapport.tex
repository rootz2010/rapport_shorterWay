\documentclass[a4paper,12pt,final] {article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[frenchb]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[autolanguage]{numprint}
\usepackage{eurosym}
\usepackage{makeidx}
\usepackage[pdftex]{hyperref}
\makeindex
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usepackage{color}
\usepackage{url}
\definecolor{vert}{rgb}{0.2,0.6,0.4} 
\definecolor{grey}{rgb}{0.95,0.95,0.95}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{geometry}
\usepackage{url}
\usepackage{pst-node, pstricks}

% for the pictures
\graphicspath{{./include/}} % déclaration du dossier d'enregistrement des photos
\DeclareGraphicsExtensions{.png,.eps,.jpg} % png, jpg etc. ne compile pas en DVI ... préférer l'eps
% enlever les extensions aux photos ?

% for the code
\usepackage{listings}
\lstset{language=[ANSI]C}

\def\subsubsubsection{\paragraph}
\def\subsubsubsubsection{\subparagraph}

\hypersetup{pdfpagemode=none,
pdfstartview=FitH,
pdfkeywords={LaTeX: document typesetting system},
breaklinks=true,
colorlinks=true,
linkcolor=black,
citecolor=black,
filecolor=black,
urlcolor=blue
}


\author{Ludovic Delaveau, Benjamin Loulier}
\title{Plus court chemin dans un graphe}

\lfoot{École Nationale Supérieure des Mines de Saint-Étienne}
\cfoot{}
\rfoot{\thepage/\pageref{LastPage}}
\lhead{Plus court chemin dans un graphe}
\chead{}
\rhead{Loulier - Delaveau}

\pagestyle{fancy}


\geometry{top=2cm}	
\geometry{bottom=3cm} % bottom margin

\begin{document}
\begin{titlepage}

\vspace*{\fill} % pour remplir le haut de la page
    \hspace*{\fill}

\begin{center}

\centering
\includegraphics[scale=0.3]{icone}\\[2cm] % bison fûté

% Title
\rule{15cm}{0.2mm} \\[0.4cm]
{ \huge \bfseries Plus court chemin dans un graphe}\\[0.4cm]
 \rule{15cm}{0.2mm} \\[0.4cm]

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Auteurs :}\\
Benjamin \textsc{Loulier}\\
Ludovic \textsc{Delaveau}\\
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Tuteurs :} \\
Roland \textsc{Jegou}\\
Michel \textsc{Beigbeder}\\
\end{flushright}
\end{minipage}
 
\vfill
Projet d'Axe informatique 2009-2010
\end{center}

\end{titlepage}

\newpage

\setcounter{page}{2} 
\tableofcontents

\newpage

\section{Introduction}

Le fait de trouver le plus court chemin dans un graphe (pathfinding en anglais) trouve énormément d'applications dans l'industrie. Un premier exemple d'application qui nous vient à l'esprit est évidemment les utilisations faites dans les GPS pour le calcul d'itinéraires, avec une valuation donnée en fonction de la distance d'un axe, mais également en fonction de l'importance de l'axe, voire même en fonction du trafic et de l'encombrement. D'autres utilisations moins connues sont par exemple les algorithmes associés au routage des données dans un réseau (application très sensible et nécessitant des algorithmes les plus performants possible, afin d'optimiser les temps de réponse entre les routeurs) ou à de l'optimisation de process.\\

Le travail fait ici s'appuie sur les graphes orientés valués, qui sont une forme de graphe la plus générique, et les algorithmes implémentés peuvent très facilement s'adaptés à des graphes non-orientés.\\

Nous avons pris le parti dans ce projet de ne traiter que des algorithmes trouvant exactement le chemin le plus court et pas un chemin optimisé. Nous avons décidé de ne pas utiliser des algorithmes approchés tels que A* car nous les avons déjà traité en première année dans le cadre du cours de java. Nous avons donc étudié trois algorithmes : L'algorithme de Bellman-Ford, l'algorithme de Dijkstra et l'algorithme de Dantzig.\\

Ce rapport se divise en trois parties principales, présentant d'abord les graphes ainsi que les structures de données que nous avons utilisées, puis les algorithmes que nous avons implémentés. Enfin l'application que nous avons réalisée sera présentée.

\newpage
\section{Définitions et structures de données}
\subsection{Graphe}

Un graphe simple est un couple formé de deux ensembles: \\
$$G=(X,A)$$ avec X l'ensemble des sommets, et A l'ensemble des arêtes.\\
$$G=(X,A,v)$$ si on ajoute la possibilité de donner une valeur différentes aux arêtes, nous avons dans ce cas un graphe valué et v est l'ensemble des valuations.\\
Un graphe peut être non orienté, auquel cas une arête entre un sommet A et B permet aussi bien de se rendre de A en B et de en A. Il peut être aussi orienté, dans ce cas une arête ne peut être parcourue que dans un sens.

\begin{figure}[htdp]
\begin{psmatrix}[mnode=circle]
         &   &   & C & E            \\
$\alpha$ & A & B & D &   & $\omega$ \\
         &   &   & F
\end{psmatrix}

\psset{arrows=->,
       labelsep=1mm,
       shortput=nab}

\ncline{2,1}{2,2}^{0} 
\ncline{2,2}{2,3}^{2} 
\ncline{2,3}{1,4}^{4} 
\ncline{2,3}{2,4}^{4} 
\ncline{2,3}{3,4}^{4}
\ncline{1,4}{1,5}^{3}
\ncline{2,4}{1,5}^{2}
\ncline{1,5}{2,4}^{2}
\ncline{3,4}{2,6}^{4}
\ncline{1,5}{2,6}^{10}

\caption{Exemple de graphe valué orienté}
\end{figure}
\subsection{Matrice d'adjacence}

plop
\begin{figure}[htdp]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
0 & 4 & $\infty$\\
\hline
8 & 0 & 3 \\
\hline
42 & $\infty$ & 0 \\
\hline
\end{tabular}
\end{center}
\caption{matrice d'adjacence}
\end{figure}%

Dans notre programme nous avons utilisé un tableau d'entiers, qui sont alloués dynamiquement puisque la taille du graphe est déterminée pendant l'exécution par l'utilisateur :
\begin{lstlisting}
int ** matrix;
\end{lstlisting}

\subsection{Tableau de liste chaînées}

Voilà la définition utilisée dans notre programme de la structure de données de liste chaînées :
\begin{lstlisting}
struct chained_list {
	int number;
	int value;
	struct chained_list * next;
};
\end{lstlisting}

Nous utilisons un tableau de liste chaînées, dont la déclaration est :
\begin{lstlisting}
struct chained_list ** list;
\end{lstlisting}
Il s'agit d'un double pointeur, puisqu'il est alloué également dynamiquement, pour les mêmes raisons que la matrice d'adjacence.

\subsection{Matrice de prédécesseur}

La matrice de prédécesseurs est l'une des deux structures de données utilisées en tant que structure de données de sortie. Elle est utilisée dans les algorithmes de Bellman-Ford et de Dijkstra, ainsi que dans une certaine mesure dans celui de Dantzig, comme nous le verrons par la suite.\\

Une matrice de prédécesseur est définie pour un noeud de départ donné. Cette matrice, telle que nous l'avons implémentée dans notre programme est de dimension ``nombre de noeuds" * 2, et stocke pour un noeud de départ donné ses prédécesseurs et les distances associées. La première colonne contient les poids des arcs qui relient le noeud de départ à la deuxième colonne, qui contient les prédécesseurs. On donne un poids nul à l'arc reliant le noeud de départ  à lui-même, et on indique $\infty$ comme prédecesseur.\\

La figure 3 donne la matrice de prédécesseur du noeud 0 du graphe décrit par la matrice d'adjacence donnée en exemple à la figure 2.\\

\begin{figure}[htdp]
\begin{center}
\begin{tabular}{|c|c|}
\hline
0 &$\infty$\\
\hline
4 & 1 \\
\hline
$\infty$ & $\infty$ \\
\hline
\end{tabular}
\end{center}
\caption{Matrice de prédécesseur pour le noeud 0 de la figure 2}
\end{figure}%

Le code utilisé pour définir la matrice n'est pas différent de celui de la matrice d'adjacence. La taille est toujours donnée dynamiquement, avec la différence cette fois que la matrice n'a que deux colonnes.
\begin{lstlisting}
int ** predecessor_matrix;
\end{lstlisting}

\subsection{``Matrice de Dantzig"}

Cette matrice, qui est comme son nom l'indique utilisée dans l'algorithme de Dantzig pour collecter les résultats, est une matrice ``nombre de noeuds" * ``nombre de noeuds" * 2. Dantzig, comme nous le verrons par la suite travaille sur le graphe entier, faisant  le calcul sur tous les sommets.\\

Dès lors, tel que nous avons implémenté la matrice, il s'agit simplement d'un tableau de n matrices de prédécesseurs, où n est le nombre de noeuds dans le graphe.\\

La figure 4 présente un exemple de cette matrice pour la matrice d'adjacence donnée à la figure 2. La matrice n'est ici pas le résultat d'un calcul de l'algorithme, et des chemins possibles n'y figurent pas, tandis que des chemins plus courts ne sont pas notés.\\

\begin{figure}[htdp]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
(0, $\infty$) & (4, 1) & ($\infty$, $\infty$) \\
\hline
(8, 0) & (0, $\infty$) & (3, 2)\\
\hline
(42, 0) & ($\infty$, $\infty$) & (0, $\infty$)\\ 
\hline
\end{tabular}
\end{center}
\caption{Matrice utilisée dans l'algorithme de Dantzig}
\end{figure}

L'implémentation d'une telle matrice est faite également très simplement, suivant ce qui est fait pour la matrice de prédécesseur. On a ici une matrice à trois dimensions, et donc un triple pointeur sur un entier :
\begin{lstlisting}
int *** matrix;
\end{lstlisting}

\subsection{choix des types de données}

Nous avons choisi d'utiliser des entiers pour représenter à la fois les noeuds et aussi leur valeur. Il nous a en effet semblé suffisant de se limiter à INT\_MAX en terme de nombre de noeuds. Cela représente tout de même \nombre{2147483647} noeuds, et une plage de valuation suffisante. La machine sera tout de façon d'abord limitée en terme d'espace mémoire pour les représenter.\\

Dans l'implémentation des algorithmes nous avons surtout utilisé des matrices, par la rapidité de temps d'accès qu'elles permettent, et aussi par la simplicité de l'implémentation qu'elles permettent. Gérer une liste sans index est en effet plus compliqué, avec des algorithmes qui utilisent en permanence des valeurs stockées précédemment. Nous le verrons par la suite, mais tous les algorithmes se servent des valeurs déjà calculées, ou remplacent celles déjà stockées.\\

\newpage
\section{Présentation des trois algorithmes}

Nous avons donc implémenté les trois algorithmes principaux de recherche de chemins, qui sont ceux de Bellman-Ford, de Dijkstra et de Dantzig. Chacun a ses propres particularités, en particulier en terme de champ d'application.\\

\subsection{Bellman-Ford}
\subsection{Dijkstra}
\subsection{Dantzig}

\newpage
\section{Application réalisée}
\subsection{Tests}
\subsection{Découpage du code}

\begin{itemize}
\item{core}
\item{io}
\item{contrôleur}
\end{itemize}

% utilisation des fichiers d'en-tête

\subsubsection{Fichier core.c}

% génération des matrices

\end{document}